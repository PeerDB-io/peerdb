package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

const grpcWrapperTemplate = `// Code generated by codegen. DO NOT EDIT.

package grpc_handler

import (
	"context"

	"github.com/PeerDB-io/peerdb/flow/generated/protos"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// APIError is the interface that typed handlers must return
// Implementations should provide a GRPCStatus() method that returns a gRPC status
type APIError interface {
	error
	GRPCStatus() *status.Status
	Code() codes.Code
}

// TypedFlowServiceServer is the same as FlowServiceServer but implementations
// return strongly-typed APIError instead of generic error
type TypedFlowServiceServer interface {
{{range .Methods}}	{{.Name}}(context.Context, *protos.{{.Request}}) (*protos.{{.Response}}, APIError)
{{end}}}

// flowServiceAdapter adapts TypedFlowServiceServer to FlowServiceServer
// converting APIError to standard error for gRPC compatibility
type flowServiceAdapter struct {
	protos.UnimplementedFlowServiceServer
	typed TypedFlowServiceServer
}

// NewFlowServiceAdapter creates a new adapter that converts between APIError and error
func NewFlowServiceAdapter(typed TypedFlowServiceServer) protos.FlowServiceServer {
	return &flowServiceAdapter{typed: typed}
}

{{range .Methods}}
func (a *flowServiceAdapter) {{.Name}}(ctx context.Context, req *protos.{{.Request}}) (*protos.{{.Response}}, error) {
	resp, apiErr := a.typed.{{.Name}}(ctx, req)
	if apiErr != nil {
		// APIError already contains a proper gRPC status, just convert to standard error
		return nil, apiErr.GRPCStatus().Err()
	}
	return resp, nil
}
{{end}}
`

type GRPCMethod struct {
	Name     string
	Request  string
	Response string
}

type GRPCTemplateData struct {
	Methods []GRPCMethod
}

func generateGRPCWrapper() error {
	// Check if the proto file exists
	protoPath := "generated/protos/route_grpc.pb.go"
	if _, err := os.Stat(protoPath); os.IsNotExist(err) {
		return fmt.Errorf(
			"required proto file %s does not exist. Please run 'buf generate protos' first to generate the proto files",
			protoPath)
	}

	// Parse the generated gRPC file
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, protoPath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse route_grpc.pb.go: %w", err)
	}

	// Find the FlowServiceServer interface
	var methods []GRPCMethod
	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if typeSpec.Name.Name == "FlowServiceServer" {
				if iface, ok := typeSpec.Type.(*ast.InterfaceType); ok {
					for _, method := range iface.Methods.List {
						funcType, ok := method.Type.(*ast.FuncType)
						if !ok {
							continue
						}
						methodName := method.Names[0].Name

						// Skip mustEmbedUnimplemented* methods
						if strings.HasPrefix(methodName, "mustEmbedUnimplemented") {
							continue
						}

						// Extract request and response types
						var request, response string

						// Get request type (second parameter after context)
						if len(funcType.Params.List) >= 2 {
							if starExpr, ok := funcType.Params.List[1].Type.(*ast.StarExpr); ok {
								if ident, ok := starExpr.X.(*ast.Ident); ok {
									request = ident.Name
								}
							}
						}

						// Get response type (first return value)
						if len(funcType.Results.List) >= 1 {
							if starExpr, ok := funcType.Results.List[0].Type.(*ast.StarExpr); ok {
								if ident, ok := starExpr.X.(*ast.Ident); ok {
									response = ident.Name
								}
							}
						}

						if request != "" && response != "" {
							methods = append(methods, GRPCMethod{
								Name:     methodName,
								Request:  request,
								Response: response,
							})
						}
					}
				}
				return false // Found the interface, stop searching
			}
		}
		return true
	})

	if len(methods) == 0 {
		return errors.New("no methods found in FlowServiceServer interface")
	}

	// Generate the output
	tmpl, err := template.New("wrapper").Parse(grpcWrapperTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, GRPCTemplateData{Methods: methods}); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Write to file
	outputDir := "generated/grpc_handler"
	if err := os.MkdirAll(outputDir, 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	outputPath := "generated/grpc_handler/typed_handler.go"
	if err := os.WriteFile(outputPath, buf.Bytes(), 0o600); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	log.Printf("Generated %s with %d methods\n", outputPath, len(methods))
	return nil
}