package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"reflect"
	"sort"
	"strings"
	"text/template"
)

const converterTemplate = `// Code generated by codegen. DO NOT EDIT.

package proto_conversions

import (
	"github.com/PeerDB-io/peerdb/flow/generated/protos"
)

// FlowConnectionConfigsToCore converts API FlowConnectionConfigs to internal FlowConnectionConfigsCore
func FlowConnectionConfigsToCore(api *protos.FlowConnectionConfigs, tableMappingsVersion int64) *protos.FlowConnectionConfigsCore {
	if api == nil {
		return nil
	}

	return &protos.FlowConnectionConfigsCore{
{{range .Fields}}		{{.GoName}}: api.{{.GoName}},
{{end}}
		TableMappings: api.TableMappings, // TODO: remove
		// TableMappingsVersion: tableMappingsVersion, // TODO: uncomment
	}
}

// FlowConnectionConfigsCoreToAPI converts internal FlowConnectionConfigsCore to API FlowConnectionConfigs
func FlowConnectionConfigsCoreToAPI(
	core *protos.FlowConnectionConfigsCore,
	tableMappings []*protos.TableMapping,
) *protos.FlowConnectionConfigs {
	if core == nil {
		return nil
	}

	return &protos.FlowConnectionConfigs{
{{range .Fields}}		{{.GoName}}: core.{{.GoName}},
{{end}}
		TableMappings: tableMappings, // TODO: remove
	}
}
`

type Field struct {
	GoName string
}

type ConverterTemplateData struct {
	Fields []Field
}

func generateFlowConfigConverter() error {
	// Parse the generated proto Go file to extract field information
	protoPath := "generated/protos/flow.pb.go"
	if _, err := os.Stat(protoPath); os.IsNotExist(err) {
		return fmt.Errorf("proto file %s does not exist, run 'buf generate protos' first", protoPath)
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, protoPath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse flow.pb.go: %w", err)
	}

	// Extract fields from both structs and verify equality
	apiFields, _, err := extractAndCompareFields(node)
	if err != nil {
		return fmt.Errorf("proto equality verification failed: %w", err)
	}

	// Convert to Field structs for template
	fields := make([]Field, 0, len(apiFields))
	for _, fieldName := range apiFields {
		fields = append(fields, Field{GoName: fieldName})
	}

	if len(fields) == 0 {
		return errors.New("no fields found in FlowConnectionConfigs")
	}

	// Generate the conversion functions
	tmpl, err := template.New("converter").Parse(converterTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, ConverterTemplateData{Fields: fields}); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Write conversion functions to file
	outputDir := "generated/proto_conversions"
	if err := os.MkdirAll(outputDir, 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	outputPath := "generated/proto_conversions/flow_config_converter.go"
	if err := os.WriteFile(outputPath, buf.Bytes(), 0o600); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	log.Printf("Generated %s with %d fields\n", outputPath, len(fields))
	return nil
}

func extractAndCompareFields(node *ast.File) ([]string, []string, error) {
	var apiFields, coreFields []string
	// Extract fields from both structs
	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			var targetFields *[]string
			if typeSpec.Name.Name == "FlowConnectionConfigs" {
				targetFields = &apiFields
			} else if typeSpec.Name.Name == "FlowConnectionConfigsCore" {
				targetFields = &coreFields
			}

			if targetFields != nil {
				if structType, ok := typeSpec.Type.(*ast.StructType); ok {
					for _, field := range structType.Fields.List {
						if len(field.Names) == 0 {
							continue
						}

						fieldName := field.Names[0].Name
						if strings.HasPrefix(fieldName, "XXX_") ||
							fieldName == "state" ||
							fieldName == "sizeCache" ||
							fieldName == "unknownFields" ||
							(typeSpec.Name.Name == "FlowConnectionConfigs" && fieldName == "TableMappings") ||
							(typeSpec.Name.Name == "FlowConnectionConfigsCore" && fieldName == "TableMappings") || // TODO: remove
							(typeSpec.Name.Name == "FlowConnectionConfigsCore" && fieldName == "TableMappingsVersion") {
							continue
						}

						*targetFields = append(*targetFields, fieldName)
					}
				}
			}
		}
		return true
	})

	// Sort for comparison
	sort.Strings(apiFields)
	sort.Strings(coreFields)

	// Check if they're equal
	if !reflect.DeepEqual(apiFields, coreFields) {
		apiSet := make(map[string]bool)
		for _, f := range apiFields {
			apiSet[f] = true
		}
		coreSet := make(map[string]bool)
		for _, f := range coreFields {
			coreSet[f] = true
		}

		var onlyInAPI, onlyInCore []string
		for f := range apiSet {
			if !coreSet[f] {
				onlyInAPI = append(onlyInAPI, f)
			}
		}
		for f := range coreSet {
			if !apiSet[f] {
				onlyInCore = append(onlyInCore, f)
			}
		}

		errMsg := "FlowConnectionConfigs and FlowConnectionConfigsCore have different fields\n"
		if len(onlyInAPI) > 0 {
			errMsg += fmt.Sprintf("Fields only in API: %v\n", strings.Join(onlyInAPI, ", "))
		}
		if len(onlyInCore) > 0 {
			errMsg += fmt.Sprintf("Fields only in Core: %v\n", strings.Join(onlyInCore, ", "))
		}
		return nil, nil, errors.New(errMsg)
	}

	log.Println("FlowConnectionConfigs are equal")
	return apiFields, coreFields, nil
}
