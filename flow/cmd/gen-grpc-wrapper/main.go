package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

const outputTemplate = `// Code generated by gen-grpc-wrapper. DO NOT EDIT.

package cmd

import (
	"context"

	"github.com/PeerDB-io/peerdb/flow/generated/protos"
)

// TypedFlowServiceServer is the same as FlowServiceServer but implementations
// return strongly-typed APIError instead of generic error
type TypedFlowServiceServer interface {
{{range .Methods}}	{{.Name}}(context.Context, *protos.{{.Request}}) (*protos.{{.Response}}, APIError)
{{end}}}

// flowServiceAdapter adapts TypedFlowServiceServer to FlowServiceServer
// converting APIError to standard error for gRPC compatibility
type flowServiceAdapter struct {
	protos.UnimplementedFlowServiceServer
	typed TypedFlowServiceServer
}

// NewFlowServiceAdapter creates a new adapter that converts between APIError and error
func NewFlowServiceAdapter(typed TypedFlowServiceServer) protos.FlowServiceServer {
	return &flowServiceAdapter{typed: typed}
}

{{range .Methods}}
func (a *flowServiceAdapter) {{.Name}}(ctx context.Context, req *protos.{{.Request}}) (*protos.{{.Response}}, error) {
	resp, apiErr := a.typed.{{.Name}}(ctx, req)
	if apiErr != nil {
		// APIError already contains a proper gRPC status, just convert to standard error
		return nil, apiErr.GRPCStatus().Err()
	}
	return resp, nil
}
{{end}}
`

type Method struct {
	Name     string
	Request  string
	Response string
}

type TemplateData struct {
	Methods []Method
}

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	// Check if the proto file exists
	protoPath := "generated/protos/route_grpc.pb.go"
	if _, err := os.Stat(protoPath); os.IsNotExist(err) {
		return fmt.Errorf("required proto file %s does not exist. Please run 'buf generate protos' first to generate the proto files", protoPath)
	}

	// Parse the generated gRPC file
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, protoPath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse route_grpc.pb.go: %w", err)
	}

	// Find the FlowServiceServer interface
	var methods []Method
	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if typeSpec.Name.Name == "FlowServiceServer" {
				if iface, ok := typeSpec.Type.(*ast.InterfaceType); ok {
					for _, method := range iface.Methods.List {
						if funcType, ok := method.Type.(*ast.FuncType); ok {
							methodName := method.Names[0].Name

							// Skip mustEmbedUnimplemented* methods
							if strings.HasPrefix(methodName, "mustEmbedUnimplemented") {
								continue
							}

							// Extract request and response types
							var request, response string

							// Get request type (second parameter after context)
							if len(funcType.Params.List) >= 2 {
								if starExpr, ok := funcType.Params.List[1].Type.(*ast.StarExpr); ok {
									if ident, ok := starExpr.X.(*ast.Ident); ok {
										request = ident.Name
									}
								}
							}

							// Get response type (first return value)
							if len(funcType.Results.List) >= 1 {
								if starExpr, ok := funcType.Results.List[0].Type.(*ast.StarExpr); ok {
									if ident, ok := starExpr.X.(*ast.Ident); ok {
										response = ident.Name
									}
								}
							}

							if request != "" && response != "" {
								methods = append(methods, Method{
									Name:     methodName,
									Request:  request,
									Response: response,
								})
							}
						}
					}
				}
				return false // Found the interface, stop searching
			}
		}
		return true
	})

	if len(methods) == 0 {
		return fmt.Errorf("no methods found in FlowServiceServer interface")
	}

	// Generate the output
	tmpl, err := template.New("wrapper").Parse(outputTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, TemplateData{Methods: methods}); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Write to file
	outputPath := "cmd/typed_handler.go"
	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	fmt.Printf("Generated %s with %d methods\n", outputPath, len(methods))
	return nil
}